// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: voter.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const deleteVoter = `-- name: DeleteVoter :one
DELETE FROM voters WHERE ethereum_address = $1 RETURNING id, full_name, email, registered_at, voted, verified, national_id_number, image_address, ethereum_address, region
`

func (q *Queries) DeleteVoter(ctx context.Context, ethereumAddress string) (Voter, error) {
	row := q.queryRow(ctx, q.deleteVoterStmt, deleteVoter, ethereumAddress)
	var i Voter
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.RegisteredAt,
		&i.Voted,
		&i.Verified,
		&i.NationalIDNumber,
		&i.ImageAddress,
		&i.EthereumAddress,
		&i.Region,
	)
	return i, err
}

const getAddress = `-- name: GetAddress :one
SELECT id, full_name, email, registered_at, voted, verified, national_id_number, image_address, ethereum_address, region FROM voters WHERE ethereum_address = $1
`

func (q *Queries) GetAddress(ctx context.Context, ethereumAddress string) (Voter, error) {
	row := q.queryRow(ctx, q.getAddressStmt, getAddress, ethereumAddress)
	var i Voter
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.RegisteredAt,
		&i.Voted,
		&i.Verified,
		&i.NationalIDNumber,
		&i.ImageAddress,
		&i.EthereumAddress,
		&i.Region,
	)
	return i, err
}

const pendingVoters = `-- name: PendingVoters :many
SELECT id, full_name, email, registered_at, voted, verified, national_id_number, image_address, ethereum_address, region FROM voters WHERE verified = false
`

func (q *Queries) PendingVoters(ctx context.Context) ([]Voter, error) {
	rows, err := q.query(ctx, q.pendingVotersStmt, pendingVoters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Voter
	for rows.Next() {
		var i Voter
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.RegisteredAt,
			&i.Voted,
			&i.Verified,
			&i.NationalIDNumber,
			&i.ImageAddress,
			&i.EthereumAddress,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerVoter = `-- name: RegisterVoter :one
INSERT INTO voters(full_name, email,national_id_number,image_address,ethereum_address, region)
VALUES($1,$2,$3,$4,$5, $6) RETURNING id
`

type RegisterVoterParams struct {
	FullName         string `json:"fullName"`
	Email            string `json:"email"`
	NationalIDNumber int64  `json:"nationalIDNumber"`
	ImageAddress     string `json:"imageAddress"`
	EthereumAddress  string `json:"ethereumAddress"`
	Region           string `json:"region"`
}

func (q *Queries) RegisterVoter(ctx context.Context, arg RegisterVoterParams) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.registerVoterStmt, registerVoter,
		arg.FullName,
		arg.Email,
		arg.NationalIDNumber,
		arg.ImageAddress,
		arg.EthereumAddress,
		arg.Region,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const totalVotedVoters = `-- name: TotalVotedVoters :one
SELECT COUNT(email) FROM voters WHERE voted = true
`

func (q *Queries) TotalVotedVoters(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.totalVotedVotersStmt, totalVotedVoters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalVotersNum = `-- name: TotalVotersNum :one
SELECT COUNT(email) FROM voters WHERE verified= true
`

func (q *Queries) TotalVotersNum(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.totalVotersNumStmt, totalVotersNum)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updatePendingState = `-- name: UpdatePendingState :one
UPDATE voters SET verified = true WHERE ethereum_address = $1 RETURNING id, full_name, email, registered_at, voted, verified, national_id_number, image_address, ethereum_address, region
`

func (q *Queries) UpdatePendingState(ctx context.Context, ethereumAddress string) (Voter, error) {
	row := q.queryRow(ctx, q.updatePendingStateStmt, updatePendingState, ethereumAddress)
	var i Voter
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.RegisteredAt,
		&i.Voted,
		&i.Verified,
		&i.NationalIDNumber,
		&i.ImageAddress,
		&i.EthereumAddress,
		&i.Region,
	)
	return i, err
}

const updateVoter = `-- name: UpdateVoter :one
UPDATE voters SET email = $1 WHERE email=$2 RETURNING id, full_name, email, registered_at, voted, verified, national_id_number, image_address, ethereum_address, region
`

type UpdateVoterParams struct {
	Email   string `json:"email"`
	Email_2 string `json:"email2"`
}

func (q *Queries) UpdateVoter(ctx context.Context, arg UpdateVoterParams) (Voter, error) {
	row := q.queryRow(ctx, q.updateVoterStmt, updateVoter, arg.Email, arg.Email_2)
	var i Voter
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.RegisteredAt,
		&i.Voted,
		&i.Verified,
		&i.NationalIDNumber,
		&i.ImageAddress,
		&i.EthereumAddress,
		&i.Region,
	)
	return i, err
}

const verifiedVoters = `-- name: VerifiedVoters :many
SELECT id, full_name, email, registered_at, voted, verified, national_id_number, image_address, ethereum_address, region FROM voters WHERE verified = true
`

func (q *Queries) VerifiedVoters(ctx context.Context) ([]Voter, error) {
	rows, err := q.query(ctx, q.verifiedVotersStmt, verifiedVoters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Voter
	for rows.Next() {
		var i Voter
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.RegisteredAt,
			&i.Voted,
			&i.Verified,
			&i.NationalIDNumber,
			&i.ImageAddress,
			&i.EthereumAddress,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
